<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPS-Berechnung</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #003366;
            --secondary-color: #009999;
            --accent-color: #FFB900;
            --background-color: #f8f9fa;
            --text-color: #333;
        }
        body {
            background-color: #fff;
            color: var(--text-color);
            font-family: '72', 'Segoe UI', Arial, sans-serif;
            font-size: 0.98rem;
        }
        .navbar {
            background-color: #003366 !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 64px;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        .navbar-brand img {
            height: 40px;
            margin-right: 12px;
        }
        .navbar-brand span {
            font-size: 1.13rem;
            font-weight: 700;
            color: #fff;
            margin-left: 0;
        }
        .container-box {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            padding: 1rem 0.8rem 0.8rem 0.8rem;
            margin-top: 0.7rem;
            margin-bottom: 0.7rem;
            max-width: 1200px;
        }
        .kalk-flex {
            display: flex;
            gap: 14px;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .kalk-card {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.10);
            border: 1px solid #e3e8ee;
            padding: 12px 10px 10px 10px;
            min-width: 220px;
            max-width: 320px;
            flex: 1 1 0;
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 7px;
        }
        .kalk-card input,
        .kalk-card select {
            width: 100%;
            margin-bottom: 6px;
            min-height: 32px;
            font-size: 0.98rem;
        }
        .kalk-card h3 {
            font-size: 1.01rem;
            font-weight: 600;
            color: #003366;
            margin-bottom: 7px;
            margin-top: 0;
        }
        .button-row {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 18px;
        }
        .button-row button {
            background: linear-gradient(90deg, #1a3b6e 60%, #009999 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.02rem;
            padding: 10px 18px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: background 0.18s, box-shadow 0.18s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .button-row button:hover {
            background: linear-gradient(90deg, #009999 60%, #1a3b6e 100%);
            box-shadow: 0 4px 16px rgba(0,0,0,0.13);
        }
        .button-row i {
            font-size: 1.1em;
        }
        @media (max-width: 1100px) {
            .kalk-flex { flex-direction: column; gap: 8px; }
            .kalk-card { max-width: 100%; min-width: 0; }
        }
        #userInfo {
            gap: 10px;
            margin-left: 32px;
        }
        #userAvatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #fff;
            box-shadow: 0 1px 4px rgba(0,0,0,0.08);
        }
        #userName {
            font-weight: 500;
            color: #fff;
            font-family: '72', 'Segoe UI', Arial, sans-serif;
        }
        .ergebnis-block { background: #fff; border-radius: 10px; box-shadow: 0 1px 4px #0001; padding: 1.2rem; margin-bottom: 1rem; }
        .preis-box { display: flex; align-items: center; gap: 10px; background: #1a3b6e; color: #fff; border-radius: 8px; padding: 0.5rem 1rem; font-size: 1.2em; margin-bottom: 1rem; }
        .preis-label { font-size: 0.9em; color: #e3e8ee; font-weight: 600; }
        .preis-wert { font-size: 1.2em; font-weight: 900; background: #2c5282; border-radius: 6px; padding: 2px 10px; margin: 0 7px; }
        .preis-einheit { font-size: 0.95em; color: #e3e8ee; }
        .ergebnis-label { font-weight: 600; color: #1a3b6e; }
        .ergebnis-wert { text-align: right; }
        hr { margin: 1rem 0; }
        .top3-table { font-size: 0.97em; }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark">
        <div class="container-fluid">
            <a class="navbar-brand d-flex align-items-center" href="#">
                <img src="LOGO.svg" alt="Logo" />
                <span>EPS-Berechnung</span>
            </a>
            <div class="d-flex align-items-center" id="userInfo" style="gap:10px; margin-left:32px;">
                <img id="userAvatar" src="https://randomuser.me/api/portraits/men/1.jpg" alt="User" style="width:32px; height:32px; border-radius:50%; object-fit:cover; border:2px solid #fff; box-shadow:0 1px 4px rgba(0,0,0,0.08);">
                <span id="userName" style="font-weight:500; color:#fff;">Benutzer</span>
            </div>
        </div>
    </nav>
    <div class="container mt-3 mb-2">
        <a href="index.html" class="btn btn-outline-primary"><i class="bi bi-arrow-left"></i> Zurück zur Startseite</a>
    </div>
    <div class="container container-box mt-3 mb-2">
        <!-- Tabs -->
        <ul class="nav nav-tabs mb-4" id="epsTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="eingabe-tab" data-bs-toggle="tab" data-bs-target="#eingabe" type="button" role="tab">
                    <i class="bi bi-pencil-square me-1"></i>Eingabe
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="visu-tab" data-bs-toggle="tab" data-bs-target="#visu" type="button" role="tab">
                    <i class="bi bi-bar-chart-line me-1"></i>Visualisierung & Ergebnis
                </button>
            </li>
        </ul>
        <div class="tab-content" id="epsTabsContent">
            <!-- Eingabe Tab -->
            <div class="tab-pane fade show active" id="eingabe" role="tabpanel">
                <form id="epsForm" onsubmit="event.preventDefault(); berechneEPS();">
                    <div class="kalk-flex">
                        <div class="kalk-card">
                            <h3>Rohblockdaten</h3>
                            <label>Artikelnummer: <input type="text" id="artikelnummer" placeholder="z.B. EPS-001"></label>
                            <label>Länge (X) [mm]: <input type="number" id="blockLaenge" required title="Länge (X) des Rohblocks in mm" value="2030"></label>
                            <label>Breite (Z) [mm]: <input type="number" id="blockBreite" required title="Breite (Z) des Rohblocks in mm" value="1020"></label>
                            <label>Höhe (Y) [mm]: <input type="number" id="blockHoehe" required title="Höhe (Y) des Rohblocks in mm" value="1230"></label>
                            <label>Rohdichte (kg/m³):
                                <select id="dichte" required title="Rohdichte des Blocks">
                                    <option value="15">15</option>
                                    <option value="18">18</option>
                                    <option value="27">27</option>
                                </select>
                            </label>
                        </div>
                        <div class="kalk-card">
                            <h3>Bauteildaten</h3>
                            <label>Länge (X) [mm]: <input type="number" id="teilLaenge" required title="Länge (X) des Bauteils in mm"></label>
                            <label>Breite (Z) [mm]: <input type="number" id="teilBreite" required title="Breite (Z) des Bauteils in mm"></label>
                            <label>Höhe (Y) [mm]: <input type="number" id="teilHoehe" required title="Höhe (Y) des Bauteils in mm"></label>
                            <label>Anzahl: <input type="number" id="anzahlTeile" min="1" value="1" required title="Wie viele Bauteile werden benötigt?"></label>
                        </div>
                        <div class="kalk-card">
                            <div class="accordion" id="prodParamAccordion">
                                <div class="accordion-item">
                                    <h2 class="accordion-header" id="xyHeading">
                                        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#xyCollapse" aria-expanded="true">
                                            <i class="bi bi-lightning-charge text-primary me-2"></i> XY-Schnitt
                                        </button>
                                    </h2>
                                    <div id="xyCollapse" class="accordion-collapse collapse show" data-bs-parent="#prodParamAccordion">
                                        <div class="accordion-body">
                                            <label>Geschwindigkeit XY (mm/min): <input type="number" id="geschwindigkeitXY" required value="600" class="form-control form-control-sm mb-2"></label>
                                            <label>Anzahl Drähte XY: <input type="number" id="anzahlDraehteXY" min="1" value="1" required class="form-control form-control-sm mb-2"></label>
                                            <div class="form-text mb-1">Wie schnell und mit wie vielen Drähten in XY geschnitten wird.</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item">
                                    <h2 class="accordion-header" id="zHeading">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#zCollapse">
                                            <i class="bi bi-lightning text-success me-2"></i> Z-Schnitt
                                        </button>
                                    </h2>
                                    <div id="zCollapse" class="accordion-collapse collapse" data-bs-parent="#prodParamAccordion">
                                        <div class="accordion-body">
                                            <label>Geschwindigkeit Z (mm/min): <input type="number" id="geschwindigkeitZ" required value="600" class="form-control form-control-sm mb-2"></label>
                                            <label>Anzahl Drähte Z: <input type="number" id="anzahlDraehteZ" min="1" value="1" required class="form-control form-control-sm mb-2"></label>
                                            <div class="form-text mb-1">Wie schnell und mit wie vielen Drähten in Z geschnitten wird.</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item">
                                    <h2 class="accordion-header" id="umstapelnHeading">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#umstapelnCollapse">
                                            <i class="bi bi-arrow-repeat text-secondary me-2"></i> Umstapeln & Verpackung
                                        </button>
                                    </h2>
                                    <div id="umstapelnCollapse" class="accordion-collapse collapse" data-bs-parent="#prodParamAccordion">
                                        <div class="accordion-body">
                                            <label>Zeitaufwand Umstapeln pro Block (min): <input type="number" id="zeitUmstapeln" min="0" value="5" required class="form-control form-control-sm mb-2"></label>
                                            <label>Abbrand pro Schnitt (mm): <input type="number" id="abbrand" min="0" value="2" required class="form-control form-control-sm mb-2"></label>
                                            <label>Preiseinheit (Menge):
                                                <select id="preiseinheit" required class="form-select form-select-sm mb-2">
                                                    <option value="1">1 Stück</option>
                                                    <option value="100" selected>100 Stück</option>
                                                    <option value="1000">1000 Stück</option>
                                                </select>
                                            </label>
                                            <label>Verpackung:
                                                <select id="verpackungstyp" onchange="toggleVerpackungFrei()" class="form-select form-select-sm mb-2">
                                                    <option value="" selected disabled>Bitte auswählen</option>
                                                    <option value="frei">Frei wählbar</option>
                                                    <option value="palette">Palette</option>
                                                    <option value="v1806">V1806</option>
                                                </select>
                                            </label>
                                            <div id="verpackungFreiFields" style="display:none;">
                                                <label>Länge (mm): <input type="number" id="verpackungLaenge" min="1" value="1200" class="form-control form-control-sm mb-2"></label>
                                                <label>Breite (mm): <input type="number" id="verpackungBreite" min="1" value="800" class="form-control form-control-sm mb-2"></label>
                                                <label>Höhe (mm): <input type="number" id="verpackungHoehe" min="1" value="2000" class="form-control form-control-sm mb-2"></label>
                                            </div>
                                            <div class="form-text mb-1">Verpackungsoptionen und Abbrand einstellen.</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <span class="hint">Der Abstand zwischen den Bauteilen entspricht dem eingestellten Abbrand.</span>
                        </div>
                    </div>
                    <div class="button-row">
                        <button type="submit"><i class="bi bi-calculator"></i> Berechnen</button>
                        <button type="button" onclick="resetForm()" style="background:#dc2626;"><i class="bi bi-arrow-counterclockwise"></i> Formular zurücksetzen</button>
                    </div>
                </form>
            </div>
            <!-- Visualisierung & Ergebnis Tab -->
            <div class="tab-pane fade" id="visu" role="tabpanel">
                <div class="kalk-flex" style="flex-direction:row; justify-content:center; align-items:stretch; gap:32px; max-width:1400px; margin:0 auto 18px auto;">
                    <div style="display:flex; flex-direction:row; gap:24px; width:100%;">
                        <div style="flex:1 1 0; min-width:320px; max-width:420px; display:flex; flex-direction:column; align-items:center;">
                            <h3 style='font-size:1.05rem; font-weight:600; color:#003366; margin-bottom:10px; margin-top:0;'>3D-Visualisierung</h3>
                            <div id="block3d" class="visual-block3d" style="width:100%; min-width:280px; min-height:220px; max-width:420px; background:#fff; margin-bottom:10px;"></div>
                        </div>
                        <div style="flex:1 1 0; min-width:320px; max-width:420px; display:flex; flex-direction:column; align-items:center;">
                            <h3 style='font-size:1.05rem; font-weight:600; color:#003366; margin-bottom:10px; margin-top:0;'>2D-Ansicht</h3>
                            <canvas id="blockCanvas" class="visual-block2d" style="width:100%; min-width:280px; min-height:220px; max-width:420px; background:#fff; margin-bottom:10px;"></canvas>
                        </div>
                        <div class="kalk-card" style="flex:1 1 0; min-width:320px; max-width:420px;">
                            <h3>Ergebnis</h3>
                            <div class="result" id="ergebnis" style="font-size:12px;"></div>
                        </div>
                    </div>
                </div>
                <div class="button-row">
                    <button type="button" onclick="berechneEPS()"><i class="bi bi-calculator"></i> Berechnen</button>
                    <button type="button" onclick="resetForm()" style="background:#dc2626;"><i class="bi bi-arrow-counterclockwise"></i> Formular zurücksetzen</button>
                    <button type="button" onclick="exportPDF()" style="background:#ffb900; color:#003366;"><i class="bi bi-file-earmark-pdf"></i> PDF exportieren</button>
                </div>
            </div>
        </div>
    </div>
    <div class="version" style="position:fixed; bottom:10px; right:10px; font-size:12px; color:#718096; background:rgba(255,255,255,0.8); padding:4px 8px; border-radius:4px; box-shadow:0 1px 3px rgba(0,0,0,0.1); z-index:999;">v1.1.0</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Funktion zum Zurücksetzen des Formulars
        function resetForm() {
            if (confirm('Möchten Sie wirklich alle Eingaben zurücksetzen?')) {
                // Formular zurücksetzen
                document.getElementById('epsForm').reset();
                // Gespeicherte Werte löschen
                localStorage.removeItem('epsFormValues');
                localStorage.removeItem('epsResults');
                localStorage.removeItem('epsDrawing');
                // Ergebnis und Zeichnung leeren
                document.getElementById('ergebnis').innerHTML = '';
                const canvas = document.getElementById('blockCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // 3D-Zeichnung leeren
                const block3d = document.getElementById('block3d');
                if (block3d) block3d.innerHTML = '';
                // Standardwerte setzen
                document.getElementById('blockLaenge').value = '2030';
                document.getElementById('blockBreite').value = '1020';
                document.getElementById('blockHoehe').value = '1230';
                setzeGeschwindigkeitNachDichte();
            }
        }

        // Speichern der Formularwerte
        function saveFormValues() {
            const formData = {};
            const formElements = document.getElementById('epsForm').elements;
            for (let element of formElements) {
                if (element.id) {
                    formData[element.id] = element.value;
                }
            }
            localStorage.setItem('epsFormValues', JSON.stringify(formData));
        }

        // Speichern der Ergebnisse
        function saveResults() {
            const results = {
                html: document.getElementById('ergebnis').innerHTML,
                canvas: document.getElementById('blockCanvas').toDataURL()
            };
            localStorage.setItem('epsResults', JSON.stringify(results));
        }

        // Laden der gespeicherten Werte
        function loadSavedValues() {
            // Formularwerte laden
            const savedValues = JSON.parse(localStorage.getItem('epsFormValues') || '{}');
            Object.keys(savedValues).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = savedValues[key];
                }
            });

            // Ergebnisse laden
            const savedResults = JSON.parse(localStorage.getItem('epsResults') || '{}');
            if (savedResults.html) {
                document.getElementById('ergebnis').innerHTML = savedResults.html;
            }
            if (savedResults.canvas) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById('blockCanvas');
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                };
                img.src = savedResults.canvas;
            }
        }

        // Event Listener für Formularänderungen
        document.getElementById('epsForm').addEventListener('input', saveFormValues);

        // Accordion beim Reset und Laden schließen
        function closeAccordionSections() {
            // Alle Accordion-Bodies schließen
            const xyCollapse = document.getElementById('xyCollapse');
            const zCollapse = document.getElementById('zCollapse');
            const umstapelnCollapse = document.getElementById('umstapelnCollapse');
            if (xyCollapse && xyCollapse.classList.contains('show')) {
                new bootstrap.Collapse(xyCollapse, {toggle: true});
            }
            if (zCollapse && zCollapse.classList.contains('show')) {
                new bootstrap.Collapse(zCollapse, {toggle: true});
            }
            if (umstapelnCollapse && umstapelnCollapse.classList.contains('show')) {
                new bootstrap.Collapse(umstapelnCollapse, {toggle: true});
            }
        }
        // Beim Reset
        const origResetForm = resetForm;
        resetForm = function() {
            origResetForm();
            closeAccordionSections();
        };
        // Beim Laden der Seite
        window.addEventListener('DOMContentLoaded', () => {
            setzeGeschwindigkeitNachDichte();
            loadSavedValues();
            closeAccordionSections();
        });

        function berechneEPS() {
            const abbrand = parseFloat(document.getElementById('abbrand').value) || 2; // mm Abbrand pro Schnitt (anpassbar)
            const gesAbstand = abbrand; // Nur Abbrand als Abstand zwischen Bauteilen
            // Eingaben holen
            const blockL = parseInt(document.getElementById('blockLaenge').value); // X
            const blockH = parseInt(document.getElementById('blockHoehe').value); // Y
            const blockB = parseInt(document.getElementById('blockBreite').value); // Z
            const teilL = parseInt(document.getElementById('teilLaenge').value); // X
            const teilH = parseInt(document.getElementById('teilHoehe').value); // Y
            const teilB = parseInt(document.getElementById('teilBreite').value); // Z
            const anzahl = parseInt(document.getElementById('anzahlTeile').value);
            const dichte = parseFloat(document.getElementById('dichte').value);
            // Warnung, falls Bauteil größer als Block
            if (teilL > blockL || teilB > blockB || teilH > blockH) {
                document.getElementById('ergebnis').innerHTML = '<span class="warn">Das Bauteil ist in mindestens einer Dimension größer als der Rohblock!</span>';
                zeichneBlock(null, null, null, null, null, null, null, null, null, null);
                return;
            }
            // Alle 6 Orientierungen prüfen
            const orientierungen = [
                { name: 'Länge-Breite-Höhe', l: teilL, b: teilB, h: teilH },
                { name: 'Länge-Höhe-Breite', l: teilL, b: teilH, h: teilB },
                { name: 'Breite-Länge-Höhe', l: teilB, b: teilL, h: teilH },
                { name: 'Breite-Höhe-Länge', l: teilB, b: teilH, h: teilL },
                { name: 'Höhe-Länge-Breite', l: teilH, b: teilL, h: teilB },
                { name: 'Höhe-Breite-Länge', l: teilH, b: teilB, h: teilL },
            ];
            // Für jede Orientierung: Wie viele Bauteile passen rein?
            let orientErgebnisse = orientierungen.map(o => {
                // Anzahl Bauteile pro Richtung (inkl. Sicherheitsabstand + Abbrand, außer am Rand)
                const nL = Math.floor((blockL + gesAbstand) / (o.l + gesAbstand));
                const nB = Math.floor((blockB + gesAbstand) / (o.b + gesAbstand));
                const nH = Math.floor((blockH + gesAbstand) / (o.h + gesAbstand));
                const maxTeile = nL * nB * nH;
                const teilVol = (o.l/1000) * (o.b/1000) * (o.h/1000); // m³
                const blockVol = (blockL/1000) * (blockB/1000) * (blockH/1000); // m³
                const gesamtTeile = Math.min(maxTeile, anzahl);
                const gesamtVol = teilVol * gesamtTeile;
                const abfallVol = blockVol - teilVol * maxTeile;
                return {
                    name: o.name,
                    nL, nB, nH,
                    maxTeile,
                    teilVol,
                    blockVol,
                    gesamtTeile,
                    gesamtVol,
                    abfallVol,
                    l: o.l, b: o.b, h: o.h
                };
            });
            // Nach Abfall sortieren (aufsteigend)
            orientErgebnisse.sort((a, b) => a.abfallVol - b.abfallVol);
            // Top 3 Orientierungen
            const top3 = orientErgebnisse.slice(0, 3);
            // Beste Orientierung für weitere Berechnung
            const beste = top3[0];
            // Wie viele Blöcke werden benötigt?
            const benoetigteBloeckeRaw = Math.ceil(anzahl / beste.maxTeile);
            const letzteBlockTeile = anzahl % beste.maxTeile === 0 ? beste.maxTeile : anzahl % beste.maxTeile;
            // Nutzungsgrad des letzten Blocks
            const nutzungsgrad = (letzteBlockTeile * beste.teilVol) / beste.blockVol;
            let benoetigteBloecke = benoetigteBloeckeRaw;
            let letzterBlockBerechnet = true;
            if (benoetigteBloeckeRaw > 1 && nutzungsgrad <= 0.5) {
                benoetigteBloecke = benoetigteBloeckeRaw - 1;
                letzterBlockBerechnet = false;
            }
            // Gewicht
            const blockGew = beste.blockVol * dichte;
            const gesamtGew = beste.teilVol * anzahl * dichte;
            // Preis je m³ nach Dichte
            let preisProM3 = 0;
            if (dichte === 15) preisProM3 = 49.70;
            else if (dichte === 18) preisProM3 = 60.68;
            else if (dichte === 27) preisProM3 = 72.42;
            // Materialkosten inkl. Abfall: gesamtes Blockvolumen wird berechnet
            let materialkosten_voll = (benoetigteBloeckeRaw - 1) * beste.blockVol * preisProM3;
            let materialkosten_letzter = 0;
            if (benoetigteBloeckeRaw === 1) {
                // Es gibt nur einen Block
                if (nutzungsgrad > 0.5) {
                    materialkosten_letzter = beste.blockVol * preisProM3;
                } else {
                    materialkosten_letzter = letzteBlockTeile * beste.teilVol * preisProM3;
                }
            } else {
                // Mehrere Blöcke
                if (nutzungsgrad > 0.5) {
                    materialkosten_letzter = beste.blockVol * preisProM3;
                } else {
                    materialkosten_letzter = letzteBlockTeile * beste.teilVol * preisProM3;
                }
            }
            const materialkosten = materialkosten_voll + materialkosten_letzter;
            const kostenProBauteil = materialkosten / anzahl;
            const kostenGesamt = materialkosten;
            // Tatsächlicher Materialwert und Abfall
            const gesamtMaterialwert = anzahl * beste.teilVol * preisProM3;
            // Abfallberechnung
            let abfallVolVoll = (benoetigteBloeckeRaw - 1) * (beste.blockVol - beste.maxTeile * beste.teilVol);
            let abfallVolRest = 0;
            if (benoetigteBloeckeRaw === 1) {
                // Nur ein Block
                if (nutzungsgrad > 0.5) {
                    abfallVolRest = beste.blockVol - (letzteBlockTeile * beste.teilVol);
                } else {
                    // Anteiliger Abfall pro Bauteil im Block
                    const abfallProBauteil = (beste.blockVol - (beste.maxTeile * beste.teilVol)) / beste.maxTeile;
                    abfallVolRest = letzteBlockTeile * abfallProBauteil;
                }
            } else {
                // Mehrere Blöcke
                if (nutzungsgrad > 0.5) {
                    abfallVolRest = beste.blockVol - (letzteBlockTeile * beste.teilVol);
                } else {
                    const abfallProBauteil = (beste.blockVol - (beste.maxTeile * beste.teilVol)) / beste.maxTeile;
                    abfallVolRest = letzteBlockTeile * abfallProBauteil;
                }
            }
            const gesamtAbfallVol = abfallVolVoll + abfallVolRest;
            const gesamtAbfallWert = gesamtAbfallVol * preisProM3;
            // --- NEU: Variablen für zweistufige Kalkulation ---
            const geschwXY = parseInt(document.getElementById('geschwindigkeitXY').value);
            const anzahlDraehteXY = Math.max(1, parseInt(document.getElementById('anzahlDraehteXY').value));
            const geschwZ = parseInt(document.getElementById('geschwindigkeitZ').value);
            const anzahlDraehteZ = Math.max(1, parseInt(document.getElementById('anzahlDraehteZ').value));
            const zeitUmstapeln = parseFloat(document.getElementById('zeitUmstapeln').value) || 0;
            // --- ENDE NEU ---
            // --- NEU: Zweistufige Schnittzeitberechnung ---
            // Schritt 1: XY-Schnitt (X und Y)
            const schnitteX = beste.nL > 0 ? beste.nL - 1 : 0;
            const schnitteY = beste.nH > 0 ? beste.nH - 1 : 0;
            const effektiveSchnitteX = Math.ceil(schnitteX / anzahlDraehteXY);
            const effektiveSchnitteY = Math.ceil(schnitteY / anzahlDraehteXY);
            const schnittwegX = effektiveSchnitteX * blockB; // X-Schnitte über Breite (Z)
            const schnittwegY = effektiveSchnitteY * blockL; // Y-Schnitte über Länge (X)
            const schnittzeitX = schnittwegX / geschwXY;
            const schnittzeitY = schnittwegY / geschwXY;
            // Schritt 2: Umstapeln
            // Zeit pro Block (eingegeben)
            // Schritt 3: Z-Schnitt
            const schnitteZ = beste.nB > 0 ? beste.nB - 1 : 0;
            const effektiveSchnitteZ = Math.ceil(schnitteZ / anzahlDraehteZ);
            const schnittwegZ = effektiveSchnitteZ * blockL; // Z-Schnitte über Länge (X)
            const schnittzeitZ = schnittwegZ / geschwZ;
            // Gesamtschnittzeit pro Block (min)
            const schnittzeitBlock = schnittzeitX + schnittzeitY + zeitUmstapeln + schnittzeitZ;
            // --- ENDE NEU ---
            // Schnittzeit pro Bauteil (min) wieder korrekt berechnen
            const schnittzeitBauteil = beste.maxTeile > 0 ? (schnittzeitBlock / beste.maxTeile) : 0;
            // Maschinenkosten (35,34 €/h) jetzt korrekt auf Basis der Schnittzeit
            const maschinenStunden = schnittzeitBlock / 60; // Stunden pro Block (exakt)
            const maschinenKostenProBlock = maschinenStunden * 35.34;
            const maschinenKostenProBauteil = beste.maxTeile > 0 ? maschinenKostenProBlock / beste.maxTeile : 0;
            const maschinenKostenGesamt = maschinenKostenProBauteil * anzahl;
            // Hilfsfunktion für Zeitformatierung (nur Stunden und Minuten)
            function formatZeitBlock(min) {
                if (!min || min === 0) return '0 min';
                const h = Math.floor(min / 60);
                const m = Math.round(min % 60);
                return (h > 0 ? h + ' h ' : '') + m + ' min';
            }

            // Hilfsfunktion für Zeitformatierung (mit Sekunden für kurze Zeiten)
            function formatZeitBauteil(min) {
                if (!min || min === 0) return '0 min';
                const h = Math.floor(min / 60);
                const m = Math.floor(min % 60);
                const s = Math.round((min % 1) * 60);
                if (min < 1) {
                    return s + ' sec';
                }
                return (h > 0 ? h + ' h ' : '') + m + ' min' + (s > 0 ? ' ' + s + ' sec' : '');
            }

            // Verpackungsmaße bestimmen (jetzt innerhalb von berechneEPS und vor der Ausgabe)
            let vL = 1200, vB = 800, vH = 2000;
            const verpackungstyp = document.getElementById('verpackungstyp').value;
            if (verpackungstyp === 'palette') { vL = 1200; vB = 800; vH = 2000; }
            else if (verpackungstyp === 'v1806') { vL = 1200; vB = 760; vH = 700; }
            else if (verpackungstyp === 'frei') {
                vL = parseInt(document.getElementById('verpackungLaenge').value) || 1;
                vB = parseInt(document.getElementById('verpackungBreite').value) || 1;
                vH = parseInt(document.getElementById('verpackungHoehe').value) || 1;
            }
            // Wie viele Bauteile passen in eine Verpackung? (optimale Stapelung)
            const nL_v = Math.floor(vL / beste.l);
            const nB_v = Math.floor(vB / beste.b);
            const nH_v = Math.floor(vH / beste.h);
            const maxProVerpackung = Math.max(1, nL_v * nB_v * nH_v);
            const benoetigteVerpackungen = Math.ceil(anzahl / maxProVerpackung);

            // Verpackungskosten berechnen
            let verpackungskosten = 0;
            if (verpackungstyp === 'v1806') {
                verpackungskosten = benoetigteVerpackungen * 3.60; // 3,60€ pro V1806 Verpackung
            }

            // Ergebnis-Tabelle
            let besteOrientierungTabelle = `<table><tr><th>Orientierung</th><th>Stück/L</th><th>Stück/B</th><th>Stück/H</th><th>Max. Stück/Block</th><th>Abfall (m³)</th></tr>`;
            besteOrientierungTabelle += `<tr><td>${beste.name}</td><td>${beste.nL}</td><td>${beste.nB}</td><td>${beste.nH}</td><td>${beste.maxTeile}</td><td>${beste.abfallVol.toFixed(3)}</td></tr>`;
            besteOrientierungTabelle += `</table>`;
            // Preis pro Preiseinheit berechnen (1, 100, 1000 Stück)
            let preisProEinheit = 0;
            let einheitText = '';
            const gesamtPreis = kostenGesamt + maschinenKostenGesamt + verpackungskosten;
            const preiseinheitMenge = parseInt(document.getElementById('preiseinheit').value);
            preisProEinheit = gesamtPreis / anzahl * preiseinheitMenge;
            einheitText = `für ${preiseinheitMenge} Stück`;
            // Ausgabe
            document.getElementById('ergebnis').innerHTML = `
                <div class="ergebnis-block">
                    <div class="preis-box">
                        <span class="preis-label">Preis</span>
                        <span class="preis-wert">${preisProEinheit.toFixed(2)} €</span>
                        <span class="preis-einheit">${einheitText}</span>
                    </div>
                    <div class="row row-cols-2 g-2 mt-2">
                        <div class="ergebnis-label">Materialwert (nur Bauteile):</div>
                        <div class="ergebnis-wert">${gesamtMaterialwert.toFixed(2)} €</div>
                        <div class="ergebnis-label">Abfall:</div>
                        <div class="ergebnis-wert">${gesamtAbfallVol.toFixed(3)} m³ (${gesamtAbfallWert.toFixed(2)} €)</div>
                        <div class="ergebnis-label">Optimale Ausrichtung:</div>
                        <div class="ergebnis-wert">${beste.name}</div>
                        <div class="ergebnis-label">Max. Bauteile pro Block:</div>
                        <div class="ergebnis-wert">${beste.maxTeile}</div>
                        <div class="ergebnis-label">Benötigte Blöcke:</div>
                        <div class="ergebnis-wert">${benoetigteBloeckeRaw}</div>
                        <div class="ergebnis-label">Bauteile im letzten Block:</div>
                        <div class="ergebnis-wert">${letzteBlockTeile}</div>
                        <div class="ergebnis-label">Verpackung:</div>
                        <div class="ergebnis-wert">${verpackungstyp === 'palette' ? 'Palette' : verpackungstyp === 'v1806' ? 'V1806' : `Frei (${vL}x${vB}x${vH} mm)`}</div>
                        <div class="ergebnis-label">Max. Bauteile pro Verpackung:</div>
                        <div class="ergebnis-wert">${maxProVerpackung}</div>
                        <div class="ergebnis-label">Benötigte Verpackungen:</div>
                        <div class="ergebnis-wert">${benoetigteVerpackungen}</div>
                        <div class="ergebnis-label">Gesamtgewicht Bauteile:</div>
                        <div class="ergebnis-wert">${gesamtGew.toFixed(2)} kg</div>
                    </div>
                    <hr>
                    <div class="row row-cols-2 g-2">
                        <div class="ergebnis-label">Materialkosten gesamt:</div>
                        <div class="ergebnis-wert">${kostenGesamt.toFixed(2)} €</div>
                        <div class="ergebnis-label">Maschinenkosten gesamt:</div>
                        <div class="ergebnis-wert">${maschinenKostenGesamt.toFixed(2)} €</div>
                        <div class="ergebnis-label">Exakte Schnittzeit pro Block:</div>
                        <div class="ergebnis-wert">${formatZeitBlock(schnittzeitBlock)}</div>
                        <div class="ergebnis-label">Exakte Schnittzeit pro Bauteil:</div>
                        <div class="ergebnis-wert">${formatZeitBauteil(schnittzeitBauteil)}</div>
                    </div>
                    <hr>
                    <div class="top3-table mt-2">
                        <b>Beste Orientierung (nach wenigstem Abfall):</b><br>
                        ${besteOrientierungTabelle}
                    </div>
                </div>
            `;
            // Zeichnung aktualisieren (Draufsicht: Block-Länge x Block-Höhe, Bauteile als Rechtecke)
            syncVisualHeights();
            zeichneBlock(blockL, blockH, beste.l, beste.h, beste.nL, beste.nH, gesAbstand, beste.maxTeile, anzahl, beste.name);
            renderBlock3D(blockL, blockB, blockH, beste.l, beste.b, beste.h, beste.nL, beste.nB, beste.nH, gesAbstand, beste.maxTeile, anzahl);
            saveFormValues();
            saveResults();
            // Tab auf "Visualisierung & Ergebnis" umschalten
            var tabTrigger = new bootstrap.Tab(document.querySelector('#visu-tab'));
            tabTrigger.show();
            // Verpackung Dropdown Umschalten
            function toggleVerpackungFrei() {
                const typ = document.getElementById('verpackungstyp').value;
                document.getElementById('verpackungFreiFields').style.display = (typ === 'frei') ? 'block' : 'none';
            }
            // Visualisierung nach Tab-Wechsel immer aktualisieren
            const visuTab = document.getElementById('visu-tab');
            if (visuTab) {
                visuTab.addEventListener('shown.bs.tab', function () {
                    // Werte aus dem Formular holen
                    const blockL = parseInt(document.getElementById('blockLaenge').value);
                    const blockH = parseInt(document.getElementById('blockHoehe').value);
                    const blockB = parseInt(document.getElementById('blockBreite').value);
                    const teilL = parseInt(document.getElementById('teilLaenge').value);
                    const teilH = parseInt(document.getElementById('teilHoehe').value);
                    const teilB = parseInt(document.getElementById('teilBreite').value);
                    const anzahl = parseInt(document.getElementById('anzahlTeile').value);
                    const abbrand = parseFloat(document.getElementById('abbrand').value) || 2;
                    const gesAbstand = abbrand;
                    // Beste Orientierung aus der letzten Berechnung holen (aus localStorage oder globaler Variable)
                    // Hier: Einfach erneut berechnen, um sicherzugehen
                    berechneEPS();
                });
            }
        }
        // Zeichnet die Anordnung der Bauteile im Block (Draufsicht X/Y)
        function zeichneBlock(blockL, blockH, teilL, teilH, nL, nH, abstand, maxTeile, anzahl, orientName) {
            // Zeichne X (Länge) und Y (Höhe) als Rechteck
            const blockB = parseInt(document.getElementById('blockBreite').value); // Z
            const canvas = document.getElementById('blockCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!blockL || !blockH || !teilL || !teilH || !nL || !nH) {
                ctx.font = '16px Helvetica';
                ctx.fillStyle = '#bbb';
                ctx.fillText('Keine Zeichnung möglich', 120, 180);
                return;
            }
            const margin = 30;
            // Maßstab für X (Länge) und Y (Höhe)
            const scaleL = (canvas.width - 2*margin) / blockL;
            const scaleH = (canvas.height - 2*margin) / blockH;
            const scale = Math.min(scaleL, scaleH);
            // Block zeichnen (X × Y)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(margin, margin, blockL*scale, blockH*scale);
            // Bauteile zeichnen (nur als grobe Darstellung, nicht exakt gestapelt wie im 3D-Block)
            let gezeichnet = 0;
            for (let i = 0; i < nL; i++) {
                for (let j = 0; j < nH; j++) {
                    if (gezeichnet >= Math.min(maxTeile, anzahl)) break;
                    // Verteile die Bauteile gleichmäßig im X/Y-Rechteck (X = teilL, Y = teilH)
                    const x = margin + i * (teilL + abstand) * scale;
                    const y = margin + j * (teilH + abstand) * scale;
                    ctx.fillStyle = '#7ec6f7';
                    ctx.strokeStyle = '#1976d2';
                    ctx.lineWidth = 1;
                    ctx.fillRect(x, y, teilL*scale, teilH*scale);
                    ctx.strokeRect(x, y, teilL*scale, teilH*scale);
                    gezeichnet++;
                }
            }
            // Legende
            ctx.font = '13px Helvetica';
            ctx.fillStyle = '#222';
            ctx.fillText('Block: Länge (X): ' + blockL + ' mm, Höhe (Y): ' + blockH + ' mm', margin, 18);
        }
        // Setzt die Standard-Schneidegeschwindigkeit je nach Dichte
        function setzeGeschwindigkeitNachDichte() {
            const dichte = document.getElementById('dichte').value;
            const geschwXYInput = document.getElementById('geschwindigkeitXY');
            const geschwZInput = document.getElementById('geschwindigkeitZ');
            if (dichte == '15') {
                geschwXYInput.value = 650;
                geschwZInput.value = 650;
            } else if (dichte == '18') {
                geschwXYInput.value = 600;
                geschwZInput.value = 600;
            } else if (dichte == '27') {
                geschwXYInput.value = 450;
                geschwZInput.value = 450;
            }
        }
        document.getElementById('dichte').addEventListener('change', setzeGeschwindigkeitNachDichte);

        // 3D-Visualisierung mit three.js
        let threeScene, threeRenderer, threeCamera, threeControls;
        function renderBlock3D(blockL, blockB, blockH, teilL, teilB, teilH, nL, nB, nH, abstand, maxTeile, anzahl) {
            const container = document.getElementById('block3d');
            // Vorherige Szene entfernen
            if (threeRenderer) {
                threeRenderer.dispose();
                container.innerHTML = '';
            }
            // Szene, Kamera, Renderer
            threeScene = new THREE.Scene();
            threeScene.background = new THREE.Color(0xf7fafc);
            const aspect = container.offsetWidth / container.offsetHeight;
            threeCamera = new THREE.PerspectiveCamera(45, aspect, 1, 10000);
            threeCamera.position.set(blockL*1.2, -blockB*1.2, blockH*1.2);
            threeCamera.up.set(0,0,1);
            threeCamera.lookAt(new THREE.Vector3(blockL/2, blockB/2, blockH/2));
            threeRenderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            threeRenderer.setSize(container.offsetWidth, container.offsetHeight);
            container.appendChild(threeRenderer.domElement);
            // Controls
            threeControls = new THREE.OrbitControls(threeCamera, threeRenderer.domElement);
            threeControls.target.set(blockL/2, blockB/2, blockH/2);
            threeControls.update();
            // Block (sichtbarer)
            const blockGeometry = new THREE.BoxGeometry(blockL, blockB, blockH);
            const blockMaterial = new THREE.MeshBasicMaterial({ color: 0x1976d2, transparent: true, opacity: 0.35, wireframe: false });
            const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial);
            blockMesh.position.set(blockL/2, blockB/2, blockH/2);
            threeScene.add(blockMesh);
            // Block-Rahmen (Wireframe)
            const edges = new THREE.EdgesGeometry(blockGeometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x1976d2, linewidth: 2 }));
            line.position.copy(blockMesh.position);
            threeScene.add(line);
            // Bauteile
            const teilGeometry = new THREE.BoxGeometry(teilL, teilB, teilH);
            let gezeichnet = 0;
            for (let i = 0; i < nL; i++) {
                for (let j = 0; j < nB; j++) {
                    for (let k = 0; k < nH; k++) {
                        if (gezeichnet >= Math.min(maxTeile, anzahl)) break;
                        // Abwechselnde Farben als Schachbrettmuster in allen Dimensionen
                        const farbe = ((i + j + k) % 2 === 0) ? 0x7ec6f7 : 0xf7b47e;
                        const teilMaterial = new THREE.MeshPhongMaterial({ color: farbe, shininess: 60 });
                        const teilMesh = new THREE.Mesh(teilGeometry, teilMaterial);
                        // Position: X = Länge, Y = Breite, Z = Höhe
                        teilMesh.position.set(
                            (i * (teilL + abstand)) + teilL/2,
                            (j * (teilB + abstand)) + teilB/2,
                            (k * (teilH + abstand)) + teilH/2
                        );
                        threeScene.add(teilMesh);
                        gezeichnet++;
                    }
                }
            }
            // Licht
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(1,1,2);
            threeScene.add(light);
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            threeScene.add(ambient);
            // Render-Loop
            function animate() {
                threeRenderer.render(threeScene, threeCamera);
                requestAnimationFrame(animate);
            }
            animate();
        }
        // Synchronisiert die Höhe und Breite der Visualisierungen mit dem Ergebnisfeld
        function syncVisualHeights() {
            const ergebnis = document.getElementById('ergebnis');
            const block3d = document.getElementById('block3d');
            const blockCanvas = document.getElementById('blockCanvas');
            if (!ergebnis || !block3d || !blockCanvas) return;
            const height = ergebnis.offsetHeight;
            block3d.style.height = height + 'px';
            blockCanvas.height = height;
            blockCanvas.style.height = height + 'px';
            // Breite anpassen (optional, für Gleichmäßigkeit)
            const width = ergebnis.offsetWidth;
            block3d.style.width = width + 'px';
            blockCanvas.width = width;
            blockCanvas.style.width = width + 'px';
        }
        window.addEventListener('resize', syncVisualHeights);

        // Nach jedem Tab-Wechsel und nach jedem Berechnen: Visualisierung neu rendern
        function ensureVisualsUpToDate() {
            // Prüfe, ob die Visualisierungs-Elemente existieren
            if (document.getElementById('block3d') && document.getElementById('blockCanvas')) {
                berechneEPS();
            }
        }
        document.addEventListener('DOMContentLoaded', function() {
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                const usernameDisplay = loggedInUser.charAt(0).toUpperCase() + loggedInUser.slice(1);
                const userNameSpan = document.getElementById('userName');
                if (userNameSpan) userNameSpan.textContent = usernameDisplay;
                const userAvatar = document.getElementById('userAvatar');
                if (userAvatar) userAvatar.src = avatarMap[loggedInUser.toLowerCase()] || 'https://randomuser.me/api/portraits/lego/1.jpg';
            }
        });

        // Avatar-Map wie auf index.html
        const avatarMap = {
            'admin': 'https://randomuser.me/api/portraits/men/1.jpg',
            'petra': 'https://randomuser.me/api/portraits/women/2.jpg',
            'jürgen': 'https://randomuser.me/api/portraits/men/3.jpg',
            'nizia': 'https://randomuser.me/api/portraits/women/4.jpg',
            'fatih': 'https://randomuser.me/api/portraits/men/5.jpg',
            'silas': 'https://randomuser.me/api/portraits/men/6.jpg',
            'julian': 'https://randomuser.me/api/portraits/men/7.jpg'
        };

        // Stelle sicher, dass berechneEPS global verfügbar ist
        window.berechneEPS = berechneEPS;

        // PDF-Export-Funktion
        function exportPDF() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            // Unsichtbares Container-Div erstellen
            let exportDiv = document.createElement('div');
            exportDiv.style.position = 'fixed';
            exportDiv.style.left = '-9999px';
            exportDiv.style.top = '0';
            exportDiv.style.background = '#fff';
            exportDiv.style.padding = '20px';
            exportDiv.style.width = '800px';
            exportDiv.style.maxWidth = '800px';
            exportDiv.style.zIndex = '-1';
            // Ergebnis kopieren
            const ergClone = document.getElementById('ergebnis').cloneNode(true);
            ergClone.style.marginBottom = '24px';
            exportDiv.appendChild(ergClone);
            // 2D-Canvas kopieren
            const canvas2d = document.getElementById('blockCanvas');
            const img2d = document.createElement('img');
            img2d.src = canvas2d.toDataURL('image/png');
            img2d.style.display = 'block';
            img2d.style.margin = '16px auto';
            img2d.style.maxWidth = '90%';
            exportDiv.appendChild(img2d);
            // 3D-Visualisierung kopieren (Canvas zu Bild)
            const block3d = document.getElementById('block3d');
            const canvas3d = block3d.querySelector('canvas');
            if (canvas3d) {
                try {
                    const img3d = document.createElement('img');
                    img3d.src = canvas3d.toDataURL('image/png');
                    img3d.style.display = 'block';
                    img3d.style.margin = '16px auto';
                    img3d.style.maxWidth = '90%';
                    exportDiv.appendChild(img3d);
                } catch (e) {
                    // Falls WebGL-Canvas nicht exportierbar ist, Hinweis anzeigen
                    const warn = document.createElement('div');
                    warn.textContent = '3D-Ansicht konnte nicht exportiert werden.';
                    warn.style.color = 'red';
                    warn.style.textAlign = 'center';
                    exportDiv.appendChild(warn);
                }
            } else {
                // Falls kein Canvas gefunden wurde
                const warn = document.createElement('div');
                warn.textContent = '3D-Ansicht nicht verfügbar.';
                warn.style.color = 'red';
                warn.style.textAlign = 'center';
                exportDiv.appendChild(warn);
            }
            document.body.appendChild(exportDiv);
            // Screenshot und PDF
            html2canvas(exportDiv, {backgroundColor: '#fff', scale:2}).then(canvas => {
                const imgData = canvas.toDataURL('image/png');
                // A4: 210x297mm, wir nutzen 200mm Breite, Höhe proportional
                const pdfWidth = 200;
                const pdfHeight = (canvas.height * pdfWidth) / canvas.width;
                pdf.addImage(imgData, 'PNG', 5, 10, pdfWidth, pdfHeight);
                pdf.save('EPS-Ergebnis.pdf');
                document.body.removeChild(exportDiv);
            });
        }
    </script>
</body>
</html>
